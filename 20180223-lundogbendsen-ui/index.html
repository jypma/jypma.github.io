<!DOCTYPE html>
<html>
  <head>
    <title>Reactive user interfaces</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="animate.min.css">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .hljs-default .hljs {
        background: #E6E4E4;
      }
      .remark-inline-code {
        background: #E6E4E4;
      }
      .small { font-size: 75%; }
      .smallright { font-size: 60%; text-align: right; margin-top: 8em; display: block; }
      .floatright { 
        clear: both;
        float: right;
        display: block;
      }
      
      .remark-slide-container {
        visibility: hidden;
        display: initial;
      }
      .remark-visible {
        visibility: visible;
      }
      .remark-slide-content.hljs-default {
         background-size: 100%; 
      }
      .remark-slide-content {
        background: #F2F4F7;
         color: #060606;
         text-shadow: 1px 1px 2px rgba(0,0,0, 0.1);
      }
      .center img {
         background: rgba(255,255,255,0.3);
         border: 1px solid #EBEBE5;
         box-shadow: 1px 1px 2px rgba(0,0,0, 0.1);
      }
      .floatright img {
         background: rgba(255,255,255,0.3);
         border: 1px solid #EBEBE5;      
         box-shadow: 1px 1px 2px rgba(0,0,0, 0.1);
      }
      .good:before { 
         content: ' '; 
         display: block; 
      }
      .good {
         color: green;
      }
      .bad:before { 
         content: ' '; 
         display: block; 
      }
      .bad {
         color: red;
      }
      pre {
         text-shadow: none;
      }
      a {
        color: #7272B6;
      }
      .remark-slide-content > ul > li {
        padding-top: 5px;
      }
      h1 {
        margin-bottom: 19px;
      }
      .mermaid {
        font-size: 16px;
      }
      span.edgeLabel {
        background-color: #F2F4F7;
      }
      @media print {
      .remark-slide-content {
        text-shadow: none;
      }      
      }
    </style>
    <!--
    <link rel="stylesheet" href="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.css">
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.js"></script>
    -->
    <link rel="stylesheet" href="mermaid.min.css">
    <script src="remark-latest.min.js"></script>
    <script src="mermaid.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Reactive user interfaces

Because the frontend â¤ buzzwords


Jan Ypma

jyp@tradeshift.com

---

# Agenda

- Rationale for rethinking documents and editing
- Something about languages and type safety...
- Editing architecture
- Demo

---

# Setting the scene

- _Tradeshift: A platform for business interactions_


- UBL (Universal Business Language)
  - A set of 60+ (huge)
  [XSDs](https://cranesoftwrights.github.io/resources/Crane-UBL-2.1-Skeleton/)
  for describing business interactions in XML
- Current systems throughput of ~10 documents per second

---

# Documents in Tradeshift, 2017

- Monolith backend knows about at least 6 different document formats
  - UBL, "jacksonified" JSON UBL, "official" JSON UBL, Portable (xml),
  Portable (JSON), Canonical
  - These are not convertable into each other without loss
- Sending a document requires it to go through several message queues
  - We have trouble growing HornetQ to our size
- Document "validations" are hardcoded, and scattered around many different places
- Document types are hardcoded
  - Introducing a new document type requires changes in 15+ places
  - As a result, existing document types have _very_ varying behaviours
- Documents are isolated to one account
  - Sending only happens once, and as an actual copy

---

# Documents in Tradeshift, 2020

- Pipeline can send 100s of documents per second, and can scale to 1000s
- Format conversions are well-defined and isolated
- New document types and validations can be introduced by anyone _on the Tradeshift network_
- People can collaborate on documents in real-time, across legal regions

---

# Event journal

.center[![doccore](journal.svg)]

- Real-time collaboration requires delta updates
- No "replace content" API
  - Instead, all edits must be saved as incremental changes
  - Edits appear on the event stream 

---

# Writing a document editor

- Traditionally
.center[![doccore](editor_old.svg)]

  - Read the whole UBL XML document
  - Transform it into a JSON variant
  - Transform it into an in-memory structure
  - Transform it into user interface elements
- User changed anything on the screen?
  - Do the above in reverse
- Another user changed anything?
  - Repeat the whole flow again

---

# Writing a reactive document editor

- Define things that constitute changes to a document
  - let's call them **events** (Redux: *action*, Elm: *message*)
--
.center[![doccore](editor_new.svg)]
- Transform a *stream* of these changes directly into user interface elements
- User changed anything on the screen?
  - Emit an event, and make sure it appears on the event stream 
- Another user changed anything?
  - Automatically handled as long as it hits the event stream

---

# Intermezzo

What does this JavaScript do?
```scala
var xhr = new XMLHttpRequest()
xhr.open("GET",
  "https://api.twitter.com/1.1/search/" +
  "tweets.json?q=%23javascript"
)
xhr.onload = (e: Event) => {
  if (xhr.status == 200) {
    var r = JSON.parse(xhr.responseTest)
    $("#tweets").html(parseTweets(r))
  }
}
xhr.send()

```

.smallright[_ * 2016, Otto Chrons, Scala.js for large and complex frontend apps_]

---

# Intermezzo

Is this really JavaScript? Look again!
```scala
var xhr = new XMLHttpRequest()
xhr.open("GET",
  "https://api.twitter.com/1.1/search/" +
  "tweets.json?q=%23javascript"
)
*xhr.onload = (e: Event) => {
  if (xhr.status == 200) {
    var r = JSON.parse(xhr.responseTest)
    $("#tweets").html(parseTweets(r))
  }
}
xhr.send()

```
This is fully type-safe Scala code.

---

# What is ScalaJS?

- Write Scala, compile to JavaScript, run in browser or NodeJS
- Supports 100% of Scala language
- Straightforward interop with JavaScript (even dynamic typing)
- As performant as hand-written JavaScript
- Generated JS code is "small enough"
  - Our PoC: 1.6MB (that's including ProtoBuf generated classes, full CLDR, streams library, everything).
- Fast edit-compile-run cycle
- Only a language, not an architecture

---

# Why a better JavaScript?
- Types: testability, refactoring, discoverability
- More modular and expressive code
- One language across client and server
- Tool-friendly and better IDE support

---

# State management

![state](edit-pipeline-with-output.svg)

- Our **Event** is `UBLDocumentEdit`, a single edit to a document
- Define intermediate [DTO classes](https://github.com/Tradeshift/document-editor/blob/master/data/src/main/scala/com/tradeshift/documents/state/Invoice.scala#L18) that holds our on-screen state
  - Immutable to make testing easier
  - Returns updated instance as result of event
  - [Unit-testable](https://github.com/Tradeshift/document-editor/blob/master/data/src/test/scala/com/tradeshift/documents/state/InvoiceSpec.scala#L30) outside of reactive framework
- State classes map to (virtual) DOM, [`example render() function`](https://github.com/Tradeshift/document-editor/blob/master/frontend/src/main/scala/com/tradeshift/documents/invoice/LineComponent.scala#L128)

---

class: center, middle

# Demo

---

# A few words about performance

- 500 events render in 10ms
- Cassandra ordering
- Protobuf deserialization
- Snapshots

---

# Choosing ScalaJS for this application

- Not the first choice
  - _React + Redux + Typescript_: not an obvious fit, not full type safety
  - _React + Redux (plain JS)_: Too verbose code (e.g. event matching)
  - _Elm_: Small developer community, maturity
- But a very nice fit
  - Very mature language and type system
  - Built-in immutability, futures, pattern matching
  - Surprisingly big community

# Conclusion

- Real-time collaboration: working
- Reactive style increases testability and state management
- Language: type safety and pattern matching
- Code reuse between server and browser

---

# Extra slides

---

# Document-core architecture

.center[![doccore](doccore.svg)]

- **document-core** : storage, access control, legal state, regionality
  - Plugins listen to its event journals and call back
- **document type plugins** : manage XSD for a particular type of document
- **validator plugins** : contribute to decide whether the legal state is OK to change to "sent"
- **augmentor plugins** : contribute additional edits whenever the document is changed (e.g. totals)

---

# Document-core pipeline

.floatright[![pipeline](pipeline.svg)]

- Documents are not copied
  - Sender and receiver use the same UUID
- Instead, document legal state is maintained
  - **Draft**: people with write access can edit the document. Validation plugins contribute to whether the document is valid for sending or not
  - **Sent**: document was valid, and now has legal status. In addition, receiver gets
  access (in default scenario)
- No way to undo sending
- No hard deletions (except for "wipe account" scenarios)

---

# Pluggable document types

- What's the big deal?
  - Tradeshift Platform doesn't want to OK every new doc type
  - Allow teams, integrators, users to experiment
- But we do want _some_ say on what's stored as a document
  - Pipeline implies knowing a _sender_ and _receiver_
  - Real-time editing needs common primitive building blocks
- UBL to the rescue: pluggable document types can use components from the following UBL namespaces, and group them into new aggregates
  - `CommonAggregateComponents-2`
  - `CommonBasicComponents-2`
  - `CommonExtensionComponents-2`
  - `QualifiedDataTypes-2`
  - `UnqualifiedDataTypes-2`
  - (and a few others)
- Document type plugin uploads an XSD to `document-core`
- XSDs are identified by their namespace
  - `xsd:annotation` indicating what's the sender and receiver

---

# Multiple regions

.center[![doccore](regions.svg)]

- Each document maintains a set of regions it is visible to
  - Granting an off-region user access to the document adds to this list
- Only on the "home" region can a document be written to (edited)
- All other regions receive read-only copies of events


---

```
curl -v -X POST \
         -H 'X-Tradeshift-ActorId: 784cfacd-8e63-4a08-b823-2c094aaf0f0c' \
         -H 'X-Tradeshift-TenantId: a0b6e3f6-54e9-4bc1-bd82-f088466acee4' \
         -H 'Content-Type:application/x-vnd.tradeshift.TSUBL' \
         -d @document-core-server/src/test/resources/smallubl.xml \
         http://localhost:8865/documents
         
curl -v \
         -H 'X-Tradeshift-ActorId: 784cfacd-8e63-4a08-b823-2c094aaf0f0c' \
         -H 'X-Tradeshift-TenantId: a0b6e3f6-54e9-4bc1-bd82-f088466acee4' \
         http://localhost:8865/documents/3eaa4f97-1080-4db0-862d-7c810ebf8031 \
         | xmllint --format -

http://localhost:8080/documents/3eaa4f97-1080-4db0-862d-7c810ebf8031

172.17.0.83
```

    </textarea>
    <script>
      var slideshow = remark.create({
          ratio: '16:9',
          highlightLanguage: "cpp",
          highlightLines: true
      });
      mermaid.initialize({startOnLoad:false, cloneCssStyles: false});
      
      function initMermaid(s) {
        var diagrams = document.querySelectorAll('.mermaid');
        var i;
        for(i=0;i<diagrams.length;i++){
          if(diagrams[i].offsetWidth>0){
            //console.log(diagrams[i]);
            //console.log(diagrams[i].childNodes[0]);
            var graphDefinition = diagrams[i].childNodes[0].childNodes[0].nodeValue;
            //console.log(graphDefinition);
            
            var insertSvg = function(svgCode, bindFunctions){
                //console.log(svgCode);
                diagrams[i].childNodes[0].innerHTML = svgCode;
            };
            
            var graph = mermaidAPI.render('graphDiv' + i, graphDefinition, insertSvg);
          }
        }
      }
      slideshow.on('afterShowSlide', initMermaid);
      initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

    </script>
</html>
